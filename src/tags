!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ANALYSE_H	analyse.h	8;"	d
ARRAY	scan.h	/^	ARRAY, BEGIN, CHAR, CONST, DO, DOWNTO, ELSE, END,$/;"	e	enum:__anon16
AS	asm/Makefile	/^AS = nasm$/;"	m
ASFLAG	asm/Makefile	/^ASFLAG = -g -f elf$/;"	m
ASSIGN	scan.h	/^	NEQ, COMMA, SEMI, ASSIGN, LPAR, RPAR, LBRA, RBRA,$/;"	e	enum:__anon16
ASymTabS	symtab.h	/^} ASymTabS;$/;"	t	typeref:struct:_ASymTabS
ASymTabSP	symtab.h	/^typedef struct _ASymTabS *ASymTabSP;$/;"	t	typeref:struct:_ASymTabS
Add_Addop_t	parse.h	/^	Nop_Addop_t, Add_Addop_t, Minus_Addop_t $/;"	e	enum:__anon2
Addop_t	parse.h	/^} Addop_t;$/;"	t	typeref:enum:__anon2
ArgListB	parse.c	/^ArgListSP ArgListB(void)$/;"	f
ArgListS	parse.h	/^} ArgListS;$/;"	t	typeref:struct:_ArgListS
ArgListSP	parse.h	/^typedef struct _ArgListS *ArgListSP;$/;"	t	typeref:struct:_ArgListS
ArgListV	analyse.c	/^void ArgListV(ArgListSP t)$/;"	f
Array_Assgin_t	parse.h	/^	Norm_Assgin_t, Fun_Assgin_t, Array_Assgin_t $/;"	e	enum:__anon8
Array_Factor_t	parse.h	/^	Id_Factor_t, Array_Factor_t, Unsign_Factor_t,$/;"	e	enum:__anon10
Array_Type_t	symtab.h	/^	Int_Type_t, Char_Type_t, Array_Type_t$/;"	e	enum:__anon15
Assgin_Stmt_t	parse.h	/^	Assgin_Stmt_t, IF_Stmt_t, Repeat_Stmt_t,$/;"	e	enum:__anon7
Assgin_t	parse.h	/^} Assgin_t;$/;"	t	typeref:enum:__anon8
AssignStmtB	parse.c	/^AssignStmtSP AssignStmtB(void)$/;"	f
AssignStmtS	parse.h	/^} AssignStmtS;$/;"	t	typeref:struct:_AssignStmtS
AssignStmtSP	parse.h	/^typedef struct _AssignStmtS *AssignStmtSP;$/;"	t	typeref:struct:_AssignStmtS
AssignStmtV	analyse.c	/^void AssignStmtV(AssignStmtSP t)$/;"	f
BEGIN	scan.h	/^	ARRAY, BEGIN, CHAR, CONST, DO, DOWNTO, ELSE, END,$/;"	e	enum:__anon16
BOOL	global.h	/^typedef int BOOL;$/;"	t
BUFLEN	scan.c	25;"	d	file:
BlockB	parse.c	/^BlockSP BlockB(void)$/;"	f
BlockS	parse.h	/^} BlockS;$/;"	t	typeref:struct:_BlockS
BlockSP	parse.h	/^typedef struct _BlockS *BlockSP;$/;"	t	typeref:struct:_BlockS
BlockV	analyse.c	/^void BlockV(BlockSP t)$/;"	f
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -Wall$/;"	m
CH	scan.h	/^	ID, CH, UNS, STRING,$/;"	e	enum:__anon16
CHAR	scan.h	/^	ARRAY, BEGIN, CHAR, CONST, DO, DOWNTO, ELSE, END,$/;"	e	enum:__anon16
COLON	scan.h	/^	LBBR, RBBR, SQUO, DQUO, COLON, DOT$/;"	e	enum:__anon16
COMMA	scan.h	/^	NEQ, COMMA, SEMI, ASSIGN, LPAR, RPAR, LBRA, RBRA,$/;"	e	enum:__anon16
COMMENT	scan.c	/^	COMMENT, DONE$/;"	e	enum:__anon12	file:
CONST	scan.h	/^	ARRAY, BEGIN, CHAR, CONST, DO, DOWNTO, ELSE, END,$/;"	e	enum:__anon16
CharArr_Var_Ident_t	parse.h	/^	IntArr_Var_Ident_t, CharArr_Var_Ident_t,$/;"	e	enum:__anon5
Char_Const_Ident_t	parse.h	/^	Int_Const_Ident_t, Char_Const_Ident_t,$/;"	e	enum:__anon5
Char_Funret_t	parse.h	/^	Int_Funret_t, Char_Funret_t $/;"	e	enum:__anon6
Char_Para_Ref_Ident_t	parse.h	/^	Int_Para_Ref_Ident_t, Char_Para_Ref_Ident_t$/;"	e	enum:__anon5
Char_Para_Val_Ident_t	parse.h	/^	Int_Para_Val_Ident_t, Char_Para_Val_Ident_t,$/;"	e	enum:__anon5
Char_Type_t	symtab.h	/^	Int_Type_t, Char_Type_t, Array_Type_t$/;"	e	enum:__anon15
Char_Var_Ident_t	parse.h	/^	Int_Var_Ident_t, Char_Var_Ident_t,$/;"	e	enum:__anon5
CompStmtB	parse.c	/^CompStmtSP CompStmtB(void)$/;"	f
CompStmtS	parse.h	/^} CompStmtS;$/;"	t	typeref:struct:_CompStmtS
CompStmtSP	parse.h	/^typedef struct _CompStmtS *CompStmtSP;$/;"	t	typeref:struct:_CompStmtS
CompStmtV	analyse.c	/^void CompStmtV(CompStmtSP t)$/;"	f
Comp_Stmt_t	parse.h	/^	Pcall_Stmt_t, Comp_Stmt_t, Read_Stmt_t,$/;"	e	enum:__anon7
CondB	parse.c	/^CondSP CondB(void)$/;"	f
CondS	parse.h	/^} CondS;$/;"	t	typeref:struct:_CondS
CondSP	parse.h	/^typedef struct _CondS *CondSP;$/;"	t	typeref:struct:_CondS
CondV	analyse.c	/^void CondV(CondSP t)$/;"	f
ConstDecB	parse.c	/^ConstDecSP ConstDecB(void)$/;"	f
ConstDecS	parse.h	/^} ConstDecS;$/;"	t	typeref:struct:_ConstDecS
ConstDecSP	parse.h	/^typedef struct _ConstDecS *ConstDecSP;$/;"	t	typeref:struct:_ConstDecS
ConstDecV	analyse.c	/^void ConstDecV(ConstDecSP t)$/;"	f
ConstDefB	parse.c	/^ConstDefSP ConstDefB(void)$/;"	f
ConstDefS	parse.h	/^} ConstDefS;$/;"	t	typeref:struct:_ConstDefS
ConstDefSP	parse.h	/^typedef struct _ConstDefS *ConstDefSP;$/;"	t	typeref:struct:_ConstDefS
ConstDefV	analyse.c	/^void ConstDefV(ConstDefSP t)$/;"	f
Const_Obj_t	symtab.h	/^	Const_Obj_t, Var_Obj_t, Type_Obj_t,$/;"	e	enum:__anon14
DO	scan.h	/^	ARRAY, BEGIN, CHAR, CONST, DO, DOWNTO, ELSE, END,$/;"	e	enum:__anon16
DONE	scan.c	/^	COMMENT, DONE$/;"	e	enum:__anon12	file:
DOT	scan.h	/^	LBBR, RBBR, SQUO, DQUO, COLON, DOT$/;"	e	enum:__anon16
DOWNTO	scan.h	/^	ARRAY, BEGIN, CHAR, CONST, DO, DOWNTO, ELSE, END,$/;"	e	enum:__anon16
DQUO	scan.h	/^	LBBR, RBBR, SQUO, DQUO, COLON, DOT$/;"	e	enum:__anon16
Disassembly	example/ref.asm	/^Disassembly of section .text:$/;"	l
Disassembly	example/val.asm	/^Disassembly of section .text:$/;"	l
Div_Multop_t	parse.h	/^	Nop_Multop_t, Mult_Multop_t, Div_Multop_t $/;"	e	enum:__anon3
Downto_For_t	parse.h	/^	To_For_t, Downto_For_t $/;"	e	enum:__anon9
ELSE	scan.h	/^	ARRAY, BEGIN, CHAR, CONST, DO, DOWNTO, ELSE, END,$/;"	e	enum:__anon16
END	scan.h	/^	ARRAY, BEGIN, CHAR, CONST, DO, DOWNTO, ELSE, END,$/;"	e	enum:__anon16
ENDFILE	scan.h	/^	ENDFILE, ERROR,$/;"	e	enum:__anon16
ENTRY	symtab.h	99;"	d
EOF_flag	scan.c	/^static BOOL EOF_flag = FALSE; \/\/ for ungetchar behavior$/;"	v	file:
EQU	scan.h	/^	PLUS, MINUS, STAR, OVER, EQU, LST, LEQ, GTT, GEQ,$/;"	e	enum:__anon16
ERRCHARLEN	error.h	15;"	d
ERRCHARTYPE	error.h	16;"	d
ERRNO	error.h	/^typedef int ERRNO;$/;"	t
ERROR	scan.h	/^	ENDFILE, ERROR,$/;"	e	enum:__anon16
ERROR_H	error.h	8;"	d
ERRSTRINGTYPE	error.h	17;"	d
ERRVEC	error.c	/^char *ERRVEC[MAXERROR] = $/;"	v
Equ_Rela_t	parse.h	/^	Equ_Rela_t, Neq_Rela_t, Gtt_Rela_t, $/;"	e	enum:__anon4
ExprB	parse.c	/^ExprSP ExprB(void)$/;"	f
ExprS	parse.h	/^} ExprS;$/;"	t	typeref:struct:_ExprS
ExprSP	parse.h	/^typedef struct _ExprS *ExprSP;$/;"	t	typeref:struct:_ExprS
ExprV	analyse.c	/^void ExprV(ExprSP t)$/;"	f
Expr_Factor_t	parse.h	/^	Expr_Factor_t, Funcall_Factor_t $/;"	e	enum:__anon10
FALSE	global.h	18;"	d
FOR	scan.h	/^	FOR, FUNCTION, IF, INTEGER, OF, PROCEDURE, READ,$/;"	e	enum:__anon16
FUNCTION	scan.h	/^	FOR, FUNCTION, IF, INTEGER, OF, PROCEDURE, READ,$/;"	e	enum:__anon16
FactorB	parse.c	/^FactorSP FactorB(void)$/;"	f
FactorS	parse.h	/^} FactorS;$/;"	t	typeref:struct:_FactorS
FactorSP	parse.h	/^typedef struct _FactorS *FactorSP;$/;"	t	typeref:struct:_FactorS
FactorV	analyse.c	/^void FactorV(FactorSP t)$/;"	f
Factor_t	parse.h	/^} Factor_t;$/;"	t	typeref:enum:__anon10
FcallStmtB	parse.c	/^FcallStmtSP FcallStmtB(void)$/;"	f
FcallStmtS	parse.h	/^} FcallStmtS;$/;"	t	typeref:struct:_FcallStmtS
FcallStmtSP	parse.h	/^typedef struct _FcallStmtS *FcallStmtSP;$/;"	t	typeref:struct:_FcallStmtS
FcallStmtV	analyse.c	/^void FcallStmtV(FcallStmtSP t)$/;"	f
ForStmtB	parse.c	/^ForStmtSP ForStmtB(void)$/;"	f
ForStmtS	parse.h	/^} ForStmtS;$/;"	t	typeref:struct:_ForStmtS
ForStmtSP	parse.h	/^typedef struct _ForStmtS *ForStmtSP;$/;"	t	typeref:struct:_ForStmtS
ForStmtV	analyse.c	/^void ForStmtV(ForStmtSP t)$/;"	f
For_Stmt_t	parse.h	/^	Write_Stmt_t,  For_Stmt_t, $/;"	e	enum:__anon7
For_t	parse.h	/^} For_t;$/;"	t	typeref:enum:__anon9
FunDecB	parse.c	/^FunDecSP FunDecB(void)$/;"	f
FunDecS	parse.h	/^} FunDecS;$/;"	t	typeref:struct:_FunDecS
FunDecSP	parse.h	/^typedef struct _FunDecS *FunDecSP;$/;"	t	typeref:struct:_FunDecS
FunDecV	analyse.c	/^void FunDecV(FunDecSP t)$/;"	f
FunDefB	parse.c	/^FunDefSP FunDefB(void)$/;"	f
FunDefS	parse.h	/^} FunDefS;$/;"	t	typeref:struct:_FunDefS
FunDefSP	parse.h	/^typedef struct _FunDefS *FunDefSP;$/;"	t	typeref:struct:_FunDefS
FunDefV	analyse.c	/^void FunDefV(FunDefSP t)$/;"	f
FunHeadB	parse.c	/^FunHeadSP FunHeadB(void)$/;"	f
FunHeadS	parse.h	/^} FunHeadS;$/;"	t	typeref:struct:_FunHeadS
FunHeadSP	parse.h	/^typedef struct _FunHeadS *FunHeadSP;$/;"	t	typeref:struct:_FunHeadS
FunHeadV	analyse.c	/^void FunHeadV(FunHeadSP t)$/;"	f
Fun_Assgin_t	parse.h	/^	Norm_Assgin_t, Fun_Assgin_t, Array_Assgin_t $/;"	e	enum:__anon8
Fun_Ident_t	parse.h	/^	Init_Ident_t, Proc_Ident_t, Fun_Ident_t, $/;"	e	enum:__anon5
Fun_Obj_t	symtab.h	/^	Proc_Obj_t, Fun_Obj_t$/;"	e	enum:__anon14
Fun_PFDec_t	parse.h	/^	Fun_PFDec_t , Proc_PFDec_t $/;"	e	enum:__anon1
Funcall_Factor_t	parse.h	/^	Expr_Factor_t, Funcall_Factor_t $/;"	e	enum:__anon10
FunctionName1	example/1.pas	/^function FunctionName1(funvar1, funvar2:char): integer;$/;"	f
FunctionName2	example/1.pas	/^function FunctionName2(var x, y: integer):char;$/;"	f
FunctionName3	example/1.pas	/^	function FunctionName3(): integer;$/;"	f
GEQ	scan.h	/^	PLUS, MINUS, STAR, OVER, EQU, LST, LEQ, GTT, GEQ,$/;"	e	enum:__anon16
GLOBAL_H	global.h	9;"	d
GTT	scan.h	/^	PLUS, MINUS, STAR, OVER, EQU, LST, LEQ, GTT, GEQ,$/;"	e	enum:__anon16
Geq_Rela_t	parse.h	/^	Geq_Rela_t, Lst_Rela_t, Leq_Rela_t $/;"	e	enum:__anon4
Gtt_Rela_t	parse.h	/^	Equ_Rela_t, Neq_Rela_t, Gtt_Rela_t, $/;"	e	enum:__anon4
HASHSIZE	symtab.h	/^int HASHSIZE = 211;$/;"	v
ID	scan.h	/^	ID, CH, UNS, STRING,$/;"	e	enum:__anon16
IDREADMODE	parse.h	/^typedef int IDREADMODE; $/;"	t
IF	scan.h	/^	FOR, FUNCTION, IF, INTEGER, OF, PROCEDURE, READ,$/;"	e	enum:__anon16
IF_Stmt_t	parse.h	/^	Assgin_Stmt_t, IF_Stmt_t, Repeat_Stmt_t,$/;"	e	enum:__anon7
INCHA	scan.c	/^	INLES, INCOM, INGRE, INCHA,$/;"	e	enum:__anon12	file:
INCOM	scan.c	/^	INLES, INCOM, INGRE, INCHA,$/;"	e	enum:__anon12	file:
INGRE	scan.c	/^	INLES, INCOM, INGRE, INCHA,$/;"	e	enum:__anon12	file:
INIDE	scan.c	/^	START, INSTR, INUNS, INIDE,$/;"	e	enum:__anon12	file:
INLES	scan.c	/^	INLES, INCOM, INGRE, INCHA,$/;"	e	enum:__anon12	file:
INSTR	scan.c	/^	START, INSTR, INUNS, INIDE,$/;"	e	enum:__anon12	file:
INTEGER	scan.h	/^	FOR, FUNCTION, IF, INTEGER, OF, PROCEDURE, READ,$/;"	e	enum:__anon16
INUNS	scan.c	/^	START, INSTR, INUNS, INIDE,$/;"	e	enum:__anon12	file:
Id_Factor_t	parse.h	/^	Id_Factor_t, Array_Factor_t, Unsign_Factor_t,$/;"	e	enum:__anon10
Id_Write_t	parse.h	/^	StrId_Write_t, Str_Write_t, Id_Write_t $/;"	e	enum:__anon11
IdentB	parse.c	/^IdentSP IdentB(IDREADMODE mode)$/;"	f
IdentS	parse.h	/^} IdentS;$/;"	t	typeref:struct:_IdentS
IdentSP	parse.h	/^typedef struct _IdentS *IdentSP;$/;"	t	typeref:struct:_IdentS
IdentV	analyse.c	/^void IdentV(IdentSP t)$/;"	f
Ident_t	parse.h	/^} Ident_t;$/;"	t	typeref:enum:__anon5
IfStmtB	parse.c	/^IfStmtSP IfStmtB(void)$/;"	f
IfStmtS	parse.h	/^} IfStmtS;$/;"	t	typeref:struct:_IfStmtS
IfStmtSP	parse.h	/^typedef struct _IfStmtS *IfStmtSP;$/;"	t	typeref:struct:_IfStmtS
IfStmtV	analyse.c	/^void IfStmtV(IfStmtSP t)$/;"	f
Indent	util.c	/^static void Indent(void)$/;"	f	file:
Init_Ident_t	parse.h	/^	Init_Ident_t, Proc_Ident_t, Fun_Ident_t, $/;"	e	enum:__anon5
IntArr_Var_Ident_t	parse.h	/^	IntArr_Var_Ident_t, CharArr_Var_Ident_t,$/;"	e	enum:__anon5
Int_Const_Ident_t	parse.h	/^	Int_Const_Ident_t, Char_Const_Ident_t,$/;"	e	enum:__anon5
Int_Funret_t	parse.h	/^	Int_Funret_t, Char_Funret_t $/;"	e	enum:__anon6
Int_Para_Ref_Ident_t	parse.h	/^	Int_Para_Ref_Ident_t, Char_Para_Ref_Ident_t$/;"	e	enum:__anon5
Int_Para_Val_Ident_t	parse.h	/^	Int_Para_Val_Ident_t, Char_Para_Val_Ident_t,$/;"	e	enum:__anon5
Int_Type_t	symtab.h	/^	Int_Type_t, Char_Type_t, Array_Type_t$/;"	e	enum:__anon15
Int_Var_Ident_t	parse.h	/^	Int_Var_Ident_t, Char_Var_Ident_t,$/;"	e	enum:__anon5
L0	asm/nice.asm	/^	L0: db "a"$/;"	d
LBBR	scan.h	/^	LBBR, RBBR, SQUO, DQUO, COLON, DOT$/;"	e	enum:__anon16
LBRA	scan.h	/^	NEQ, COMMA, SEMI, ASSIGN, LPAR, RPAR, LBRA, RBRA,$/;"	e	enum:__anon16
LEQ	scan.h	/^	PLUS, MINUS, STAR, OVER, EQU, LST, LEQ, GTT, GEQ,$/;"	e	enum:__anon16
LFLAG	asm/Makefile	/^LFLAG = -g$/;"	m
LK	asm/Makefile	/^LK = ld$/;"	m
LPAR	scan.h	/^	NEQ, COMMA, SEMI, ASSIGN, LPAR, RPAR, LBRA, RBRA,$/;"	e	enum:__anon16
LST	scan.h	/^	PLUS, MINUS, STAR, OVER, EQU, LST, LEQ, GTT, GEQ,$/;"	e	enum:__anon16
Leq_Rela_t	parse.h	/^	Geq_Rela_t, Lst_Rela_t, Leq_Rela_t $/;"	e	enum:__anon4
Lst_Rela_t	parse.h	/^	Geq_Rela_t, Lst_Rela_t, Leq_Rela_t $/;"	e	enum:__anon4
MAXERROR	error.h	10;"	d
MAXRESERVED	global.h	29;"	d
MAXTOKENSIZE	scan.h	27;"	d
MINUS	scan.h	/^	PLUS, MINUS, STAR, OVER, EQU, LST, LEQ, GTT, GEQ,$/;"	e	enum:__anon16
MISSDOT	error.h	18;"	d
Minus_Addop_t	parse.h	/^	Nop_Addop_t, Add_Addop_t, Minus_Addop_t $/;"	e	enum:__anon2
Mult_Multop_t	parse.h	/^	Nop_Multop_t, Mult_Multop_t, Div_Multop_t $/;"	e	enum:__anon3
Multop_t	parse.h	/^} Multop_t;$/;"	t	typeref:enum:__anon3
NEQ	scan.h	/^	NEQ, COMMA, SEMI, ASSIGN, LPAR, RPAR, LBRA, RBRA,$/;"	e	enum:__anon16
NEWNODE	parse.h	263;"	d
NEWSYMTAB	symtab.h	78;"	d
Neq_Rela_t	parse.h	/^	Equ_Rela_t, Neq_Rela_t, Gtt_Rela_t, $/;"	e	enum:__anon4
Nop_Addop_t	parse.h	/^	Nop_Addop_t, Add_Addop_t, Minus_Addop_t $/;"	e	enum:__anon2
Nop_Multop_t	parse.h	/^	Nop_Multop_t, Mult_Multop_t, Div_Multop_t $/;"	e	enum:__anon3
Norm_Assgin_t	parse.h	/^	Norm_Assgin_t, Fun_Assgin_t, Array_Assgin_t $/;"	e	enum:__anon8
Null_Stmt_t	parse.h	/^	Null_Stmt_t $/;"	e	enum:__anon7
OBJS	Makefile	/^OBJS = main.o util.o scan.o error.o parse.o analyse.o$/;"	m
OF	scan.h	/^	FOR, FUNCTION, IF, INTEGER, OF, PROCEDURE, READ,$/;"	e	enum:__anon16
OVER	scan.h	/^	PLUS, MINUS, STAR, OVER, EQU, LST, LEQ, GTT, GEQ,$/;"	e	enum:__anon16
Obj_t	symtab.h	/^} Obj_t;$/;"	t	typeref:enum:__anon14
PARSE_H	parse.h	8;"	d
PFDecListB	parse.c	/^PFDecListSP PFDecListB(void)$/;"	f
PFDecListS	parse.h	/^} PFDecListS;$/;"	t	typeref:struct:_PFDecListS
PFDecListSP	parse.h	/^typedef struct _PFDecListS *PFDecListSP;$/;"	t	typeref:struct:_PFDecListS
PFDecListV	analyse.c	/^void PFDecListV(PFDecListSP t)$/;"	f
PFDec_t	parse.h	/^} PFDec_t;$/;"	t	typeref:enum:__anon1
PLUS	scan.h	/^	PLUS, MINUS, STAR, OVER, EQU, LST, LEQ, GTT, GEQ,$/;"	e	enum:__anon16
PROCEDURE	scan.h	/^	FOR, FUNCTION, IF, INTEGER, OF, PROCEDURE, READ,$/;"	e	enum:__anon16
ParaDefB	parse.c	/^ParaDefSP ParaDefB(void)$/;"	f
ParaDefS	parse.h	/^} ParaDefS;$/;"	t	typeref:struct:_ParaDefS
ParaDefSP	parse.h	/^typedef struct _ParaDefS *ParaDefSP;$/;"	t	typeref:struct:_ParaDefS
ParaDefV	analyse.c	/^void ParaDefV(ParaDefSP t)$/;"	f
ParaListB	parse.c	/^ParaListSP ParaListB(void)$/;"	f
ParaListS	parse.h	/^} ParaListS;$/;"	t	typeref:struct:_ParaListS
ParaListSP	parse.h	/^typedef struct _ParaListS *ParaListSP;$/;"	t	typeref:struct:_ParaListS
ParaListV	analyse.c	/^void ParaListV(ParaListSP t)$/;"	f
PcallStmtB	parse.c	/^PcallStmtSP PcallStmtB(void)$/;"	f
PcallStmtS	parse.h	/^} PcallStmtS;$/;"	t	typeref:struct:_PcallStmtS
PcallStmtSP	parse.h	/^typedef struct _PcallStmtS *PcallStmtSP;$/;"	t	typeref:struct:_PcallStmtS
PcallStmtV	analyse.c	/^void PcallStmtV(PcallStmtSP t)$/;"	f
Pcall_Stmt_t	parse.h	/^	Pcall_Stmt_t, Comp_Stmt_t, Read_Stmt_t,$/;"	e	enum:__anon7
PgmB	parse.c	/^PgmSP PgmB(void)$/;"	f
PgmS	parse.h	/^} PgmS;$/;"	t	typeref:struct:_PgmS
PgmSP	parse.h	/^typedef struct _PgmS *PgmSP;$/;"	t	typeref:struct:_PgmS
PgmV	analyse.c	/^void PgmV(PgmSP t)$/;"	f
PrintSource	main.c	/^BOOL PrintSource = FALSE;$/;"	v
ProcDecB	parse.c	/^ProcDecSP ProcDecB(void)$/;"	f
ProcDecS	parse.h	/^} ProcDecS;$/;"	t	typeref:struct:_ProcDecS
ProcDecSP	parse.h	/^typedef struct _ProcDecS *ProcDecSP;$/;"	t	typeref:struct:_ProcDecS
ProcDecV	analyse.c	/^void ProcDecV(ProcDecSP t)$/;"	f
ProcDefB	parse.c	/^ProcDefSP ProcDefB(void)$/;"	f
ProcDefS	parse.h	/^} ProcDefS;$/;"	t	typeref:struct:_ProcDefS
ProcDefSP	parse.h	/^typedef struct _ProcDefS *ProcDefSP;$/;"	t	typeref:struct:_ProcDefS
ProcDefV	analyse.c	/^void ProcDefV(ProcDefSP t)$/;"	f
ProcHeadB	parse.c	/^ProcHeadSP ProcHeadB(void)$/;"	f
ProcHeadS	parse.h	/^} ProcHeadS;$/;"	t	typeref:struct:_ProcHeadS
ProcHeadSP	parse.h	/^typedef struct _ProcHeadS *ProcHeadSP;$/;"	t	typeref:struct:_ProcHeadS
ProcHeadV	analyse.c	/^void ProcHeadV(ProcHeadSP t)$/;"	f
Proc_Ident_t	parse.h	/^	Init_Ident_t, Proc_Ident_t, Fun_Ident_t, $/;"	e	enum:__anon5
Proc_Obj_t	symtab.h	/^	Proc_Obj_t, Fun_Obj_t$/;"	e	enum:__anon14
Proc_PFDec_t	parse.h	/^	Fun_PFDec_t , Proc_PFDec_t $/;"	e	enum:__anon1
ProcedureName1	example/1.pas	/^procedure ProcedureName1();$/;"	p
ProcedureName2	example/1.pas	/^	procedure ProcedureName2(var num:integer);$/;"	p
RBBR	scan.h	/^	LBBR, RBBR, SQUO, DQUO, COLON, DOT$/;"	e	enum:__anon16
RBRA	scan.h	/^	NEQ, COMMA, SEMI, ASSIGN, LPAR, RPAR, LBRA, RBRA,$/;"	e	enum:__anon16
READ	scan.h	/^	FOR, FUNCTION, IF, INTEGER, OF, PROCEDURE, READ,$/;"	e	enum:__anon16
READCURR	parse.h	257;"	d
READPREV	parse.h	258;"	d
REPEAT	scan.h	/^	REPEAT, THEN, TO, UNTIL, VAR, WRITE,$/;"	e	enum:__anon16
RPAR	scan.h	/^	NEQ, COMMA, SEMI, ASSIGN, LPAR, RPAR, LBRA, RBRA,$/;"	e	enum:__anon16
ReadStmtB	parse.c	/^ReadStmtSP ReadStmtB(void)$/;"	f
ReadStmtS	parse.h	/^} ReadStmtS;$/;"	t	typeref:struct:_ReadStmtS
ReadStmtSP	parse.h	/^typedef struct _ReadStmtS *ReadStmtSP;$/;"	t	typeref:struct:_ReadStmtS
ReadStmtV	analyse.c	/^void ReadStmtV(ReadStmtSP t)$/;"	f
Read_Stmt_t	parse.h	/^	Pcall_Stmt_t, Comp_Stmt_t, Read_Stmt_t,$/;"	e	enum:__anon7
Rela_t	parse.h	/^} Rela_t;$/;"	t	typeref:enum:__anon4
RepeStmtB	parse.c	/^RepeStmtSP RepeStmtB(void)$/;"	f
RepeStmtS	parse.h	/^} RepeStmtS;$/;"	t	typeref:struct:_RepeStmtS
RepeStmtSP	parse.h	/^typedef struct _RepeStmtS *RepeStmtSP;$/;"	t	typeref:struct:_RepeStmtS
RepeStmtV	analyse.c	/^void RepeStmtV(RepeStmtSP t)$/;"	f
Repeat_Stmt_t	parse.h	/^	Assgin_Stmt_t, IF_Stmt_t, Repeat_Stmt_t,$/;"	e	enum:__anon7
Return_t	parse.h	/^} Return_t;$/;"	t	typeref:enum:__anon6
SCAN_H	scan.h	9;"	d
SECTION	asm/hello.asm	/^SECTION	.DATA$/;"	l
SECTION	asm/hello.asm	/^SECTION .TEXT$/;"	l
SEMI	scan.h	/^	NEQ, COMMA, SEMI, ASSIGN, LPAR, RPAR, LBRA, RBRA,$/;"	e	enum:__anon16
SHIFT	symtab.h	/^int SHIFT = 4;$/;"	v
SQUO	scan.h	/^	LBBR, RBBR, SQUO, DQUO, COLON, DOT$/;"	e	enum:__anon16
STAR	scan.h	/^	PLUS, MINUS, STAR, OVER, EQU, LST, LEQ, GTT, GEQ,$/;"	e	enum:__anon16
START	scan.c	/^	START, INSTR, INUNS, INIDE,$/;"	e	enum:__anon12	file:
STRING	scan.h	/^	ID, CH, UNS, STRING,$/;"	e	enum:__anon16
SYMTAB_H	symtab.h	8;"	d
ShowAST	main.c	/^BOOL ShowAST = TRUE;$/;"	v
ShowTip	main.c	/^BOOL ShowTip = FALSE;$/;"	v
StateType	scan.c	/^} StateType;$/;"	t	typeref:enum:__anon12	file:
StmtB	parse.c	/^StmtSP StmtB(void)$/;"	f
StmtS	parse.h	/^} StmtS;$/;"	t	typeref:struct:_StmtS
StmtSP	parse.h	/^typedef struct _StmtS *StmtSP;$/;"	t	typeref:struct:_StmtS
StmtV	analyse.c	/^void StmtV(StmtSP t)$/;"	f
Stmt_t	parse.h	/^} Stmt_t;$/;"	t	typeref:enum:__anon7
StrId_Write_t	parse.h	/^	StrId_Write_t, Str_Write_t, Id_Write_t $/;"	e	enum:__anon11
Str_Write_t	parse.h	/^	StrId_Write_t, Str_Write_t, Id_Write_t $/;"	e	enum:__anon11
SymBucketS	symtab.h	/^} SymBucketS;$/;"	t	typeref:struct:_SymBucketS
SymBucketSP	symtab.h	/^typedef struct _SymBucketS *SymBucketSP;$/;"	t	typeref:struct:_SymBucketS
SymLineS	symtab.h	/^} SymLineS;$/;"	t	typeref:struct:_SymLineS
SymLineSP	symtab.h	/^typedef struct _SymLineS *SymLineSP;$/;"	t	typeref:struct:_SymLineS
SymTabES	symtab.h	/^} SymTabES;$/;"	t	typeref:struct:_SymTabES
SymTabESP	symtab.h	/^typedef struct _SymTabES *SymTabESP;$/;"	t	typeref:struct:_SymTabES
SymTabS	symtab.h	/^} SymTabS;$/;"	t	typeref:struct:_SymTabS
SymTabSP	symtab.h	/^typedef struct _SymTabS *SymTabSP;$/;"	t	typeref:struct:_SymTabS
TEST	parse.h	273;"	d
TEST2	parse.h	274;"	d
TEST3	parse.h	275;"	d
TEST4	parse.h	276;"	d
TEST5	parse.h	277;"	d
TEST6	parse.h	279;"	d
THEN	scan.h	/^	REPEAT, THEN, TO, UNTIL, VAR, WRITE,$/;"	e	enum:__anon16
TO	scan.h	/^	REPEAT, THEN, TO, UNTIL, VAR, WRITE,$/;"	e	enum:__anon16
TRUE	global.h	22;"	d
TermB	parse.c	/^TermSP TermB(void)$/;"	f
TermS	parse.h	/^} TermS;$/;"	t	typeref:struct:_TermS
TermSP	parse.h	/^typedef struct _TermS *TermSP;$/;"	t	typeref:struct:_TermS
TermV	analyse.c	/^void TermV(TermSP t)$/;"	f
To_For_t	parse.h	/^	To_For_t, Downto_For_t $/;"	e	enum:__anon9
TokenType	scan.h	/^} TokenType;$/;"	t	typeref:enum:__anon16
TraceScan	main.c	/^BOOL TraceScan = FALSE;$/;"	v
Type_Obj_t	symtab.h	/^	Const_Obj_t, Var_Obj_t, Type_Obj_t,$/;"	e	enum:__anon14
Type_t	symtab.h	/^} Type_t;$/;"	t	typeref:enum:__anon15
UNS	scan.h	/^	ID, CH, UNS, STRING,$/;"	e	enum:__anon16
UNTIL	scan.h	/^	REPEAT, THEN, TO, UNTIL, VAR, WRITE,$/;"	e	enum:__anon16
UTIL_H	util.h	9;"	d
Unsign_Factor_t	parse.h	/^	Id_Factor_t, Array_Factor_t, Unsign_Factor_t,$/;"	e	enum:__anon10
VAR	scan.h	/^	REPEAT, THEN, TO, UNTIL, VAR, WRITE,$/;"	e	enum:__anon16
VarDecB	parse.c	/^VarDecSP VarDecB(void)$/;"	f
VarDecS	parse.h	/^} VarDecS;$/;"	t	typeref:struct:_VarDecS
VarDecSP	parse.h	/^typedef struct _VarDecS *VarDecSP;$/;"	t	typeref:struct:_VarDecS
VarDecV	analyse.c	/^void VarDecV(VarDecSP t)$/;"	f
VarDefB	parse.c	/^VarDefSP VarDefB(void)$/;"	f
VarDefS	parse.h	/^} VarDefS;$/;"	t	typeref:struct:_VarDefS
VarDefSP	parse.h	/^typedef struct _VarDefS *VarDefSP;$/;"	t	typeref:struct:_VarDefS
VarDefV	analyse.c	/^void VarDefV(VarDefSP t)$/;"	f
Var_Obj_t	symtab.h	/^	Const_Obj_t, Var_Obj_t, Type_Obj_t,$/;"	e	enum:__anon14
WRITE	scan.h	/^	REPEAT, THEN, TO, UNTIL, VAR, WRITE,$/;"	e	enum:__anon16
WriteStmtB	parse.c	/^WriteStmtSP WriteStmtB(void)$/;"	f
WriteStmtS	parse.h	/^} WriteStmtS;$/;"	t	typeref:struct:_WriteStmtS
WriteStmtSP	parse.h	/^typedef struct _WriteStmtS *WriteStmtSP;$/;"	t	typeref:struct:_WriteStmtS
WriteStmtV	analyse.c	/^void WriteStmtV(WriteStmtSP t)$/;"	f
Write_Stmt_t	parse.h	/^	Write_Stmt_t,  For_Stmt_t, $/;"	e	enum:__anon7
Write_t	parse.h	/^} Write_t;$/;"	t	typeref:enum:__anon11
_ASymTabS	symtab.h	/^typedef struct _ASymTabS {$/;"	s
_ArgListS	parse.h	/^typedef struct _ArgListS {$/;"	s
_AssignStmtS	parse.h	/^typedef struct _AssignStmtS {$/;"	s
_BlockS	parse.h	/^typedef struct _BlockS {$/;"	s
_CompStmtS	parse.h	/^typedef struct _CompStmtS {$/;"	s
_CondS	parse.h	/^typedef struct _CondS {$/;"	s
_ConstDecS	parse.h	/^typedef struct _ConstDecS {$/;"	s
_ConstDefS	parse.h	/^typedef struct _ConstDefS {$/;"	s
_ExprS	parse.h	/^typedef struct _ExprS {$/;"	s
_FactorS	parse.h	/^typedef struct _FactorS {$/;"	s
_FcallStmtS	parse.h	/^typedef struct _FcallStmtS {$/;"	s
_ForStmtS	parse.h	/^typedef struct _ForStmtS {$/;"	s
_FunDecS	parse.h	/^typedef struct _FunDecS {$/;"	s
_FunDefS	parse.h	/^typedef struct _FunDefS {$/;"	s
_FunHeadS	parse.h	/^typedef struct _FunHeadS {$/;"	s
_IdentS	parse.h	/^typedef struct _IdentS {$/;"	s
_IfStmtS	parse.h	/^typedef struct _IfStmtS {$/;"	s
_PFDecListS	parse.h	/^typedef struct _PFDecListS {$/;"	s
_ParaDefS	parse.h	/^typedef struct _ParaDefS {$/;"	s
_ParaListS	parse.h	/^typedef struct _ParaListS {$/;"	s
_PcallStmtS	parse.h	/^typedef struct _PcallStmtS {$/;"	s
_PgmS	parse.h	/^typedef struct _PgmS {$/;"	s
_ProcDecS	parse.h	/^typedef struct _ProcDecS {$/;"	s
_ProcDefS	parse.h	/^typedef struct _ProcDefS {$/;"	s
_ProcHeadS	parse.h	/^typedef struct _ProcHeadS {$/;"	s
_ReadStmtS	parse.h	/^typedef struct _ReadStmtS {$/;"	s
_RepeStmtS	parse.h	/^typedef struct _RepeStmtS {$/;"	s
_StmtS	parse.h	/^typedef struct _StmtS {$/;"	s
_SymBucketS	symtab.h	/^typedef struct _SymBucketS {$/;"	s
_SymLineS	symtab.h	/^typedef struct _SymLineS {$/;"	s
_SymTabES	symtab.h	/^typedef struct _SymTabES {$/;"	s
_SymTabS	symtab.h	/^typedef struct _SymTabS {$/;"	s
_TermS	parse.h	/^typedef struct _TermS {$/;"	s
_VarDecS	parse.h	/^typedef struct _VarDecS {$/;"	s
_VarDefS	parse.h	/^typedef struct _VarDefS {$/;"	s
_WriteStmtS	parse.h	/^typedef struct _WriteStmtS {$/;"	s
_start	asm/hello.asm	/^_start:$/;"	l
_start	asm/inte.asm	/^_start:$/;"	l
_start	asm/nice.asm	/^_start:$/;"	l
a	asm/printf1.asm	/^	a:	dd	5		; int a=5;$/;"	d
a	example/val.asm	/^   a:	66 c7 45 fc 07 00    	movw   $0x7,-0x4(%ebp)$/;"	l
adjustscale	example/pascals.pas	/^procedure adjustscale;$/;"	p
alp	parse.h	/^	ArgListSP alp;$/;"	m	struct:_FcallStmtS
alp	parse.h	/^	ArgListSP alp;$/;"	m	struct:_PcallStmtS
analyse	analyse.c	/^void analyse(PgmSP t)$/;"	f
ap	symtab.h	/^	ASymTabSP ap; 		\/\/ array vector pointer$/;"	m	struct:_SymTabES
arraytyp	example/pascals.pas	/^procedure arraytyp(var aref, arsz: integer);$/;"	p
asp	parse.h	/^	AssignStmtSP asp;$/;"	m	struct:_StmtS
assignment	example/pascals.pas	/^procedure assignment(lv, ad: integer);$/;"	p
block	example/pascals.pas	/^procedure block(fsys: symset; isfun: boolean; level: integer);$/;"	p
bp	parse.h	/^	BlockSP bp;$/;"	m	struct:_FunDefS
bp	parse.h	/^	BlockSP bp;$/;"	m	struct:_PgmS
bp	parse.h	/^	BlockSP bp;$/;"	m	struct:_ProcDefS
bufsize	scan.c	/^static int bufsize = 0;      \/\/ current size of buffered string$/;"	v	file:
c	example/ref.asm	/^   c:	66 c7 00 07 00       	movw   $0x7,(%eax)$/;"	l
call	example/pascals.pas	/^procedure call(fsys: symset; i: integer);$/;"	p
caselabel	example/pascals.pas	/^procedure caselabel;$/;"	p
casestatement	example/pascals.pas	/^procedure casestatement;$/;"	p
cdp	parse.h	/^	ConstDecSP cdp;$/;"	m	struct:_BlockS
cdp	parse.h	/^	ConstDefSP cdp;$/;"	m	struct:_ConstDecS
char_to_long	scan.c	/^BOOL char_to_long = FALSE;$/;"	v
compoundstatement	example/pascals.pas	/^procedure compoundstatement;$/;"	p
constant	example/pascals.pas	/^procedure constant(fsys: symset; var c: conrec);$/;"	p
constantdeclaration	example/pascals.pas	/^procedure constantdeclaration;$/;"	p
copyString	util.c	/^char *copyString(char *s)$/;"	f
cp	parse.h	/^	CondSP cp;$/;"	m	struct:_IfStmtS
cp	parse.h	/^	CondSP cp;$/;"	m	struct:_RepeStmtS
cpp	parse.h	/^	CompStmtSP cpp;$/;"	m	struct:_StmtS
csp	parse.h	/^	CompStmtSP csp;$/;"	m	struct:_BlockS
emit	example/pascals.pas	/^procedure emit(fct: integer);$/;"	p
emit1	example/pascals.pas	/^procedure emit1(fct, b: integer);$/;"	p
emit2	example/pascals.pas	/^procedure emit2(fct, a, b: integer);$/;"	p
enter	example/pascals.pas	/^procedure enter(id: alfa; k: object);$/;"	p
enter	example/pascals.pas	/^procedure enter(x0: alfa; x1: object;$/;"	p
enterarray	example/pascals.pas	/^procedure enterarray(tp: types; l, h: integer);$/;"	p
enterblock	example/pascals.pas	/^procedure enterblock;$/;"	p
enterreal	example/pascals.pas	/^procedure enterreal(x: real);$/;"	p
entervariable	example/pascals.pas	/^procedure entervariable;$/;"	p
ep	parse.h	/^	ExprSP ep;$/;"	m	struct:_ArgListS
ep	parse.h	/^	ExprSP ep;$/;"	m	struct:_FactorS
ep	parse.h	/^	ExprSP ep;$/;"	m	struct:_WriteStmtS
ep	parse.h	/^	StmtSP ep;$/;"	m	struct:_IfStmtS
ep	symtab.h	/^	SymTabESP ep;		\/\/ element infomation$/;"	m	struct:_SymBucketS
errlist	main.c	/^FILE *errlist;$/;"	v
error	example/pascals.pas	/^procedure error(n: integer);$/;"	p
errormsg	example/pascals.pas	/^procedure errormsg;$/;"	p
exit	asm/inte.asm	/^exit:$/;"	l
expression	example/pascals.pas	/^procedure expression;$/;"	p
factor	example/pascals.pas	/^procedure factor(fsys: symset; var x: item);$/;"	p
fatal	example/pascals.pas	/^procedure fatal(n: integer);$/;"	p
fcsp	parse.h	/^	FcallStmtSP fcsp;$/;"	m	struct:_FactorS
fdp	parse.h	/^	FunDecSP fdp; $/;"	m	struct:_PFDecListS
fdp	parse.h	/^	FunDefSP fdp;$/;"	m	struct:_FunDecS
fhp	parse.h	/^	FunHeadSP fhp;$/;"	m	struct:_FunDefS
fmt	asm/printf1.asm	/^fmt:    db "a=%d, eax=%d", 10, 0 ; The printf format, "\\n",'0'$/;"	d
forstatement	example/pascals.pas	/^procedure forstatement;$/;"	p
fp	parse.h	/^	FactorSP fp;$/;"	m	struct:_TermS
frp	parse.h	/^	ForStmtSP frp;$/;"	m	struct:_StmtS
getNextChar	scan.c	/^static int getNextChar(BOOL flag)$/;"	f	file:
getToken	scan.c	/^TokenType getToken(void)$/;"	f
getsym	parse.c	/^static inline void getsym(void)$/;"	f	file:
hash	symtab.c	/^static int hash(char *key)$/;"	f	file:
headPr	util.c	/^void headPr(char *cont)$/;"	f
hello	asm/inte.asm	/^	hello: db "hello", 10$/;"	d
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_AssignStmtS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_ConstDefS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_FactorS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_FcallStmtS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_ForStmtS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_FunHeadS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_ParaDefS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_PcallStmtS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_ProcHeadS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_ReadStmtS
idp	parse.h	/^	IdentSP idp;$/;"	m	struct:_VarDefS
ifp	parse.h	/^	IfStmtSP ifp;$/;"	m	struct:_StmtS
ifstatement	example/pascals.pas	/^procedure ifstatement;$/;"	p
indentno	util.c	/^static int indentno = 0;$/;"	v	file:
innerCharPr	util.c	/^void innerCharPr(char val)$/;"	f
innerIdnPr	util.c	/^void innerIdnPr(int n, ...)$/;"	f
innerIdnlnPr	util.c	/^void innerIdnlnPr(int n, ...)$/;"	f
innerIntPr	util.c	/^void innerIntPr(int val)$/;"	f
innerPr	util.c	/^void innerPr(int n, ...)$/;"	f
innerlnPr	util.c	/^void innerlnPr(int n, ...)$/;"	f
insymbol	example/pascals.pas	/^procedure insymbol;   (* reads next symbol *)$/;"	p
interpret	example/pascals.pas	/^procedure interpret;$/;"	p
len	asm/hello.asm	/^	len: equ $-msg$/;"	d
len	asm/inte.asm	/^	len: equ $-hello$/;"	d
length	parse.h	/^	int length;$/;"	m	struct:_IdentS
length	symtab.h	/^	int length;$/;"	m	struct:_ASymTabS
lep	parse.h	/^	ExprSP lep;$/;"	m	struct:_AssignStmtS
lep	parse.h	/^	ExprSP lep;$/;"	m	struct:_CondS
lep	parse.h	/^	ExprSP lep;$/;"	m	struct:_ForStmtS
lev	symtab.h	/^	int lev;		\/\/ level$/;"	m	struct:_SymTabES
lexError	error.c	/^void lexError(ERRNO errno)$/;"	f
line	parse.h	/^	int line;$/;"	m	struct:_IdentS
lineBuf	scan.c	/^static char lineBuf[BUFLEN]; \/\/ hold the current line$/;"	v	file:
lineno	main.c	/^int lineno = 0;$/;"	v
lineno	symtab.h	/^	int lineno;$/;"	m	struct:_SymLineS
linepos	scan.c	/^static int linepos = 0;      \/\/ current position in lineBuf$/;"	v	file:
lines	symtab.h	/^	SymLineSP lines;	\/\/ referenced lines$/;"	m	struct:_SymTabES
listing	main.c	/^FILE *listing;$/;"	v
loc	example/pascals.pas	/^function loc(id: alfa): integer;$/;"	f
main	asm/printf1.asm	/^main:				; the program label for the entry point$/;"	l
main	main.c	/^int main(int argc, const char *argv[])$/;"	f
match	parse.c	/^static inline BOOL match(TokenType expected)$/;"	f	file:
max	example/5.pas	/^function max(num1, num2: integer): integer;$/;"	f
msg	asm/hello.asm	/^	msg:	db 'Hello world!', 10$/;"	d
name	parse.h	/^	char *name;$/;"	m	struct:_IdentS
name	symtab.h	/^	char *name;		\/\/ identifier name$/;"	m	struct:_SymTabES
next	parse.h	/^	ArgListSP next;$/;"	m	struct:_ArgListS
next	parse.h	/^	CompStmtSP next;$/;"	m	struct:_CompStmtS
next	parse.h	/^	ConstDecSP next;$/;"	m	struct:_ConstDecS
next	parse.h	/^	ExprSP next;$/;"	m	struct:_ExprS
next	parse.h	/^	FunDecSP next;$/;"	m	struct:_FunDecS
next	parse.h	/^	PFDecListSP next;$/;"	m	struct:_PFDecListS
next	parse.h	/^	ParaDefSP next;$/;"	m	struct:_ParaDefS
next	parse.h	/^	ParaListSP next;$/;"	m	struct:_ParaListS
next	parse.h	/^	ProcDecSP next;$/;"	m	struct:_ProcDecS
next	parse.h	/^	ReadStmtSP next;$/;"	m	struct:_ReadStmtS
next	parse.h	/^	TermSP next;$/;"	m	struct:_TermS
next	parse.h	/^	VarDecSP next;$/;"	m	struct:_VarDecS
next	parse.h	/^	VarDefSP next;$/;"	m	struct:_VarDefS
next	symtab.h	/^	SymBucketSP next;$/;"	m	struct:_SymBucketS
next	symtab.h	/^	SymLineSP next;$/;"	m	struct:_SymLineS
next	symtab.h	/^	SymTabSP next;$/;"	m	struct:_SymTabS
nextch	example/pascals.pas	/^procedure nextch; (* read next character; process line end *)$/;"	p
obj	symtab.h	/^	Obj_t obj;		\/\/ object type$/;"	m	struct:_SymTabES
onecase	example/pascals.pas	/^procedure onecase;$/;"	p
op	parse.h	/^	Addop_t op;$/;"	m	struct:_ExprS
op	parse.h	/^	Multop_t op;$/;"	m	struct:_TermS
op	parse.h	/^	Rela_t op;$/;"	m	struct:_CondS
parameterlist	example/pascals.pas	/^procedure parameterlist; (* formal parameter list *)$/;"	p
parse	parse.c	/^PgmSP parse(void)$/;"	f
pcp	parse.h	/^	PcallStmtSP pcp;$/;"	m	struct:_StmtS
pdp	parse.h	/^	ParaDefSP pdp;$/;"	m	struct:_ParaListS
pdp	parse.h	/^	ProcDecSP pdp; $/;"	m	struct:_PFDecListS
pdp	parse.h	/^	ProcDefSP pdp;$/;"	m	struct:_ProcDecS
pfdlp	parse.h	/^	PFDecListSP pfdlp;$/;"	m	struct:_BlockS
php	parse.h	/^	ProcHeadSP php;$/;"	m	struct:_ProcDefS
plp	parse.h	/^	ParaListSP plp;$/;"	m	struct:_FunHeadS
plp	parse.h	/^	ParaListSP plp;$/;"	m	struct:_ProcHeadS
pop	symtab.c	/^static inline SymTabSP pop()$/;"	f	file:
preTokenLocation	parse.c	/^static int preTokenLocation;$/;"	v	file:
prev	symtab.h	/^	SymTabSP prev;$/;"	m	struct:_SymTabS
prevToken	parse.c	/^static TokenType prevToken;$/;"	v	file:
prevTokenString	parse.c	/^static char prevTokenString[MAXTOKENSIZE + 1];$/;"	v	file:
printToken	util.c	/^void printToken(TokenType token, const char *tokenString)$/;"	f
printtables	example/pascals.pas	/^procedure printtables;$/;"	p
procdeclaration	example/pascals.pas	/^procedure procdeclaration;$/;"	p
push	symtab.c	/^static inline void push(SymTabSP t)$/;"	f	file:
rdp	parse.h	/^	ReadStmtSP rdp;$/;"	m	struct:_StmtS
readscale	example/pascals.pas	/^   procedure readscale;$/;"	p
rep	parse.h	/^	ExprSP rep;$/;"	m	struct:_AssignStmtS
rep	parse.h	/^	ExprSP rep;$/;"	m	struct:_CondS
rep	parse.h	/^	ExprSP rep;$/;"	m	struct:_ForStmtS
repeatstatement	example/pascals.pas	/^procedure repeatstatement;$/;"	p
reservedLookup	scan.c	/^static TokenType reservedLookup(char *s)$/;"	f	file:
reservedWords	scan.c	/^} reservedWords[MAXRESERVED] = $/;"	v	typeref:struct:__anon13	file:
resulttype	example/pascals.pas	/^function resulttype(a, b: types): types;$/;"	f
rpp	parse.h	/^	RepeStmtSP rpp;$/;"	m	struct:_StmtS
sbp	symtab.h	/^	SymBucketSP *sbp;$/;"	m	struct:_SymTabS
section	asm/inte.asm	/^section	.text$/;"	l
section	asm/inte.asm	/^section .data$/;"	l
section	asm/nice.asm	/^section .data$/;"	l
section	asm/nice.asm	/^section .text$/;"	l
selector	example/pascals.pas	/^procedure selector(fsys: symset; var v: item);$/;"	p
sematicError	error.c	/^void sematicError(ERRNO errno)$/;"	f
simpleexpression	example/pascals.pas	/^procedure simpleexpression(fsys: symset; var x: item);$/;"	p
skip	example/pascals.pas	/^procedure skip(fsys: symset; n: integer);$/;"	p
source	main.c	/^FILE *source;$/;"	v
sp	parse.h	/^	StmtSP sp;$/;"	m	struct:_CompStmtS
sp	parse.h	/^	StmtSP sp;$/;"	m	struct:_ForStmtS
sp	parse.h	/^	StmtSP sp;$/;"	m	struct:_RepeStmtS
sp	parse.h	/^	char *sp;$/;"	m	struct:_WriteStmtS
standfct	example/pascals.pas	/^procedure standfct(n: integer);$/;"	p
standproc	example/pascals.pas	/^procedure standproc(n: integer);$/;"	p
statement	example/pascals.pas	/^procedure statement(fsys: symset);$/;"	p
stdout	asm/inte.asm	/^stdout		equ	1$/;"	d
stp	symtab.h	/^	SymTabSP stp; 		\/\/ point to symbol table$/;"	m	struct:_SymTabES
str	scan.c	/^	char *str;$/;"	m	struct:__anon13	file:
swap	example/2.pas	/^procedure swap(var x,y:integer);$/;"	p
swap	example/4.pas	/^procedure swap(var x,y:integer);$/;"	p
swap	example/nice.pas	/^procedure swap(var x,y:integer); { pass by address }$/;"	p
sym_insert	symtab.c	/^void sym_insert(char *name, Identp idp)$/;"	f
syntaxError	error.c	/^void syntaxError(ERRNO errno)$/;"	f
sys_exit	asm/inte.asm	/^sys_exit	equ	1$/;"	d
sys_write	asm/inte.asm	/^sys_write	equ	4$/;"	d
tailPr	util.c	/^void tailPr(char *cont)$/;"	f
term	example/pascals.pas	/^procedure term(fsys: symset; var x: item);$/;"	p
test	example/pascals.pas	/^procedure test(s1, s2: symset; n: integer);$/;"	p
testsemicolon	example/pascals.pas	/^procedure testsemicolon;$/;"	p
tiplist	main.c	/^FILE *tiplist;$/;"	v
tok	scan.c	/^	TokenType tok;$/;"	m	struct:__anon13	file:
token	parse.c	/^static TokenType token; \/* hold current token*\/$/;"	v	file:
tokenCount	util.c	/^int tokenCount = 0;$/;"	v
tokenLocation	scan.c	/^int tokenLocation;$/;"	v
tokenString	scan.c	/^char tokenString[MAXTOKENSIZE + 1];$/;"	v
top	symtab.c	/^SymTabSP top = NULL;$/;"	v
tp	parse.h	/^	StmtSP tp;$/;"	m	struct:_IfStmtS
tp	parse.h	/^	TermSP tp;$/;"	m	struct:_ExprS
typ	example/pascals.pas	/^procedure typ(fsys: symset; var tp: types; var rf, sz: integer);$/;"	p
type	parse.h	/^	Assgin_t type;$/;"	m	struct:_AssignStmtS
type	parse.h	/^	Factor_t type;$/;"	m	struct:_FactorS
type	parse.h	/^	For_t type;$/;"	m	struct:_ForStmtS
type	parse.h	/^	Ident_t type;$/;"	m	struct:_IdentS
type	parse.h	/^	PFDec_t type;$/;"	m	struct:_PFDecListS
type	parse.h	/^	Return_t type;$/;"	m	struct:_FunHeadS
type	parse.h	/^	Stmt_t type;$/;"	m	struct:_StmtS
type	parse.h	/^	Write_t type;$/;"	m	struct:_WriteStmtS
type	symtab.h	/^	Type_t type;		\/\/ type $/;"	m	struct:_SymTabES
type	symtab.h	/^	Type_t type;$/;"	m	struct:_ASymTabS
typedeclaration	example/pascals.pas	/^procedure typedeclaration;$/;"	p
ungetNextChar	scan.c	/^static void ungetNextChar(void)$/;"	f	file:
usi	parse.h	/^	int usi;$/;"	m	struct:_FactorS
val	parse.h	/^	int val;$/;"	m	struct:_IdentS
value	example/ref.pas	/^procedure value(var num:integer);$/;"	p
value	example/val.pas	/^procedure value(num:integer);$/;"	p
variabledeclaration	example/pascals.pas	/^procedure variabledeclaration;$/;"	p
vdp	parse.h	/^	VarDecSP vdp;$/;"	m	struct:_BlockS
vdp	parse.h	/^	VarDefSP vdp;$/;"	m	struct:_VarDecS
whilestatement	example/pascals.pas	/^procedure whilestatement;$/;"	p
write	asm/inte.asm	/^write:$/;"	l
wtp	parse.h	/^	WriteStmtSP wtp;$/;"	m	struct:_StmtS
